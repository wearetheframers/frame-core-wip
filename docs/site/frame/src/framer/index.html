<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.1">
<title>frame.src.framer API documentation</title>
<meta name="description" content="">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>frame.src.framer</code></h1>
</header>
<section id="section-intro">
</section>
<section>
<h2 class="section-title" id="header-submodules">Sub-modules</h2>
<dl>
<dt><code class="name"><a title="frame.src.framer.agency" href="agency/index.html">frame.src.framer.agency</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="frame.src.framer.brain" href="brain/index.html">frame.src.framer.brain</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="frame.src.framer.config" href="config.html">frame.src.framer.config</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="frame.src.framer.framer" href="framer.html">frame.src.framer.framer</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="frame.src.framer.framer_factory" href="framer_factory.html">frame.src.framer.framer_factory</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="frame.src.framer.soul" href="soul/index.html">frame.src.framer.soul</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="frame.src.framer.Framer"><code class="flex name class">
<span>class <span class="ident">Framer</span></span>
<span>(</span><span>config: <a title="frame.src.framer.config.FramerConfig" href="config.html#frame.src.framer.config.FramerConfig">FramerConfig</a>, llm_service: <a title="frame.src.services.llm.main.LLMService" href="../services/llm/main.html#frame.src.services.llm.main.LLMService">LLMService</a>, agency: <a title="frame.src.framer.agency.agency.Agency" href="agency/agency.html#frame.src.framer.agency.agency.Agency">Agency</a>, brain: <a title="frame.src.framer.brain.brain.Brain" href="brain/brain.html#frame.src.framer.brain.brain.Brain">Brain</a>, soul: <a title="frame.src.framer.soul.soul.Soul" href="soul/soul.html#frame.src.framer.soul.soul.Soul">Soul</a>, workflow_manager: <a title="frame.src.framer.agency.workflow.workflow_manager.WorkflowManager" href="agency/workflow/workflow_manager.html#frame.src.framer.agency.workflow.workflow_manager.WorkflowManager">WorkflowManager</a>, memory_adapter: Optional[<a title="frame.src.framer.brain.memory.memory_adapter_interface.MemoryAdapterInterface" href="brain/memory/memory_adapter_interface.html#frame.src.framer.brain.memory.memory_adapter_interface.MemoryAdapterInterface">MemoryAdapterInterface</a>] = None, memory_service: Optional[<a title="frame.src.services.memory.main.MemoryService" href="../services/memory/main.html#frame.src.services.memory.main.MemoryService">MemoryService</a>] = None, eq_service: Optional[<a title="frame.src.services.eq.main.EQService" href="../services/eq/main.html#frame.src.services.eq.main.EQService">EQService</a>] = None, roles: List[Dict[str, Any]] = [], goals: List[Dict[str, Any]] = [], plugins: Optional[Dict[str, Any]] = None, plugin_loading_progress: Optional[Callable[[int], None]] = None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Framer:
    perceptions_queue: Deque[Union[Perception, Dict[str, Any]]] = deque()
    &#34;&#34;&#34;
    The Framer class represents an AI agent with cognitive capabilities. It integrates various components
    such as agency, brain, soul, and workflow management to create a comprehensive AI entity capable of
    processing perceptions, making decisions, and executing tasks.

    Attributes:
        config (FramerConfig): Configuration settings for the Framer.
        llm_service (LLMService): The language model service to be used by the Framer.
        agency (Agency): Manages roles, goals, tasks, and workflows for the Framer.
        brain (Brain): Handles decision-making processes, integrating perceptions, memories, and thoughts.
        soul (Soul): Represents the core essence and personality of a Framer.
        workflow_manager (WorkflowManager): Manages workflows and tasks.
        memory_service (Optional[MemoryService]): Service for managing memory. Default is None.
        eq_service (Optional[EQService]): Service for managing emotional intelligence. Default is None.
        roles (Optional[List[Dict[str, Any]]]): List of roles for the Framer. Default is None.
        goals (Optional[List[Dict[str, Any]]]): List of goals for the Framer. Default is None.
        observers (List[Observer]): List of observer functions to notify on decisions.
        can_execute (bool): Determines if decisions are executed automatically. Default is True.
        acting (bool): Indicates if the Framer is actively processing perceptions. Default is False.
    &#34;&#34;&#34;

    def __init__(
        self,
        config: FramerConfig,
        llm_service: LLMService,
        agency: Agency,
        brain: Brain,
        soul: Soul,
        workflow_manager: WorkflowManager,
        memory_adapter: Optional[MemoryAdapterInterface] = None,
        memory_service: Optional[MemoryService] = None,
        eq_service: Optional[EQService] = None,
        roles: List[Dict[str, Any]] = [],
        goals: List[Dict[str, Any]] = [],
        plugins: Optional[Dict[str, Any]] = None,
        plugin_loading_progress: Optional[Callable[[int], None]] = None,
    ):
        self.plugin_loading_progress = plugin_loading_progress
        # Existing initialization code...

        self.config = config
        self.permissions = config.permissions or [&#34;with_memory&#34;, &#34;with_mem0_search_extract_summarize_plugin&#34;, &#34;with_shared_context&#34;]

        # Initialize services and plugins based on permissions
        # Services like memory, eq, and shared_context are special plugins called services.
        # They do not require explicit permissions to be accessed but must be passed into a Framer.
        # The Mem0SearchExtractSummarizePlugin is a default plugin that provides a response mechanism
        # requiring memory retrieval, functioning as a RAG mechanism.
        # Enforce permission for &#39;with-mem0-search-extract-summarize-plugin&#39; if &#39;with-memory&#39; is used
        if &#34;with-memory&#34; in self.permissions:
            self.permissions.append(&#34;with-mem0-search-extract-summarize-plugin&#34;)
        
        if &#34;with-memory&#34; in self.permissions and memory_adapter:
            self.memory_service = memory_service or MemoryService(adapter=memory_adapter)

        if &#34;with_eq&#34; in self.permissions:
            self.eq_service = eq_service or EQService()

        if &#34;with_shared_context&#34; in self.permissions:
            self.shared_context_service = SharedContext()

        self.config = config
        self.llm_service = llm_service
        self.agency = agency
        self.brain = brain
        self.soul = soul
        self.workflow_manager = workflow_manager
        self.memory_service = memory_service
        self.roles = roles
        self.goals = goals
        self.eq_service = eq_service
        self.plugins = plugins or {}
        self.plugin_loading_complete = False
        self._streamed_response = {&#34;status&#34;: &#34;pending&#34;, &#34;result&#34;: &#34;&#34;}
        self.config = config
        self.llm_service = llm_service
        self.agency = agency
        self.brain = brain
        self.soul = soul
        self.workflow_manager = workflow_manager
        self.memory_service = memory_service
        self.eq_service = eq_service
        self._dynamic_model_choice = False
        self.observers: List[Observer] = []
        self.can_execute = True  # Add can_execute attribute
        self.acting = False
        # Load plugins asynchronously
        asyncio.create_task(self.load_plugins())

    def act(self):
        &#34;&#34;&#34;
        Enable the Framer to start acting and processing perceptions.
        &#34;&#34;&#34;
        self.acting = True
            
    async def load_plugins(self):
        &#34;&#34;&#34;
        Load all plugins by calling their on_load method.
        &#34;&#34;&#34;
        for plugin_name, plugin_instance in self.plugins.items():
            if hasattr(plugin_instance, &#34;on_load&#34;):
                await plugin_instance.on_load(self)
                # Register plugin actions
                for action_name, action_func in plugin_instance.get_actions().items():
                    self.agency.action_registry.add_action(
                        action_name,
                        action_func=action_func,
                        description=f&#34;Action from {plugin_name} plugin&#34;,
                        priority=5  # Default priority, adjust as needed
                    )
        self.plugin_loading_complete = True
        self.act()
        await self.process_queued_perceptions()

    async def process_queued_perceptions(self):
        &#34;&#34;&#34;
        Process all queued perceptions once the Framer is ready.
        &#34;&#34;&#34;
        if self.is_ready():
            logger.info(&#34;Processing queued perceptions...&#34;)
            while self.perceptions_queue:
                logger.info(f&#34;Processing perception from queue: {self.perceptions_queue[0]}&#34;)
                perception = self.perceptions_queue.popleft()
                await self.sense(perception)

            if not self.roles and not self.goals:
                self.roles, self.goals = await self.agency.generate_roles_and_goals()
            elif not self.roles:
                self.roles, _ = await self.agency.generate_roles_and_goals()
            elif not self.goals:
                _, self.goals = await self.agency.generate_roles_and_goals()

            # Sort roles and goals by priority
            self.roles.sort(key=lambda x: x.get(&#34;priority&#34;, 5), reverse=True)
            self.goals.sort(key=lambda x: x.get(&#34;priority&#34;, 5), reverse=True)

            self.agency.set_roles(self.roles)
            self.agency.set_goals(self.goals)
        else:
            logger.warning(&#34;Framer is not ready. Queuing perception.&#34;)
            logger.info(f&#34;Queued perception: {perception}&#34;)

        # Sort roles and goals by priority
        self.roles.sort(key=lambda x: x.get(&#34;priority&#34;, 5), reverse=True)
        self.goals.sort(key=lambda x: x.get(&#34;priority&#34;, 5), reverse=True)

        self.agency.set_roles(self.roles)
        self.agency.set_goals(self.goals)

    async def export_to_file(self, file_path: str, llm) -&gt; None:
        &#34;&#34;&#34;
        Export the Framer configuration to a JSON file.

        This method allows the Framer agent to be fully exported into a JSON format,
        making it portable and easy to use inside a prompt to any other LLM. This
        portability enables the Framer agents to be shared and consumed by other
        systems, facilitating interoperability and reuse.

        Args:
            file_path (str): The path to the file where the JSON will be saved.
        &#34;&#34;&#34;
        config = self.config
        config.soul_seed = self.soul.seed
        config.roles = self.roles
        config.goals = self.goals
        config_dict = config.to_dict()
        with open(file_path, &#34;w&#34;) as f:
            json.dump(config_dict, f, indent=4)

    @classmethod
    def load_from_file(
        cls,
        file_path: str,
        llm_service: LLMService,
        memory_service: Optional[MemoryService] = None,
        eq_service: Optional[EQService] = None,
    ) -&gt; &#34;Framer&#34;:
        &#34;&#34;&#34;
        Load a Framer configuration from a file.

        This method allows importing a Framer agent from a JSON or markdown file,
        enabling the reconstruction of the agent&#39;s state and configuration. This
        functionality is crucial for restoring Framer agents from saved states,
        ensuring continuity and consistency across different sessions or environments.

        Args:
            file_path (str): The path to the configuration file.
            llm_service (LLMService): Language model service.
            memory_service (Optional[MemoryService]): Memory service for the Framer.
            eq_service (Optional[EQService]): Emotional intelligence service for the Framer.

        Returns:
            Framer: A new Framer instance configured from the file.
        &#34;&#34;&#34;
        config = parse_json_config(file_path)
        return cls(
            config=config,
            llm_service=llm_service,
            agency=Agency(llm_service=llm_service, context=None),
            brain=Brain(
                llm_service=llm_service,
                default_model=config.default_model,
                roles=config.roles if config.roles is not None else [],
                goals=config.goals if config.goals is not None else [],
                soul=Soul(seed=config.soul_seed),
            ),
            soul=Soul(seed=config.soul_seed),
            workflow_manager=WorkflowManager(),
            memory_service=memory_service,
            eq_service=eq_service,
            roles=config.roles if config.roles is not None else [],
            goals=config.goals if config.goals is not None else [],
        )

    def export_to_markdown(self, file_path: str) -&gt; None:
        &#34;&#34;&#34;
        Export the Framer configuration to a Markdown file.

        This method allows the Framer agent to be fully exported into a Markdown format,
        making it portable and easy to use inside a prompt to any other LLM. This
        portability enables the Framer agents to be shared and consumed by other
        systems, facilitating interoperability and reuse.

        Args:
            file_path (str): The path to the file where the Markdown will be saved.
        &#34;&#34;&#34;
        from frame.src.utils.config_parser import export_config_to_markdown

        export_config_to_markdown(self.config, file_path)

    async def use_plugin_action(self, plugin_name: str, action_name: str, parameters: Dict[str, Any]) -&gt; Any:
        &#34;&#34;&#34;
        Execute a plugin action directly.

        Args:
            plugin_name (str): The name of the plugin.
            action_name (str): The name of the action to execute.
            parameters (Dict[str, Any]): Parameters for the action.

        Returns:
            Any: The result of the action execution.
        &#34;&#34;&#34;
        # Get the plugin instance
        plugin = self.plugins.get(plugin_name)
        if not plugin:
            logger.warning(f&#34;Plugin {plugin_name} not found. Skipping action.&#34;)
            return {&#34;error&#34;: f&#34;Plugin {plugin_name} not found.&#34;}
        
        action = getattr(plugin, action_name, None)
        if not action:
            raise ValueError(f&#34;Action {action_name} not found in plugin {plugin_name}.&#34;)
        
        return await action(**parameters)
    
    async def perform_task(self, task: Dict[str, Any]) -&gt; Dict[str, Any]:
        &#34;&#34;&#34;
        Perform a task asynchronously.

        Args:
            task (Dict[str, Any]): Dictionary containing task details.

        Returns:
            Dict[str, Any]: Result of the task execution.
        &#34;&#34;&#34;
        logger.debug(f&#34;perform_task called with task: {task}&#34;)
        valid_task_keys = Task.__annotations__.keys()
        task_filtered = {k: v for k, v in task.items() if k in valid_task_keys}
        # Ensure required fields are present
        if &#34;description&#34; not in task_filtered:
            task_filtered[&#34;description&#34;] = &#34;Default Task Description&#34;
        if &#34;workflow_id&#34; not in task_filtered:
            task_filtered[&#34;workflow_id&#34;] = &#34;default&#34;

        task_obj = Task(**task_filtered)
        result = await self.perform_task(task_obj.to_dict())
        return result if result is not None else {&#34;output&#34;: &#34;No result returned&#34;}

    def is_ready(self) -&gt; bool:
        &#34;&#34;&#34;
        Check if the Framer is ready to process perceptions and make decisions.

        Returns:
            bool: True if the Framer is ready, False otherwise.
        &#34;&#34;&#34;
        return self.plugin_loading_complete and self.acting

    async def sense(self, perception: Union[Perception, Dict[str, Any]]) -&gt; Optional[Decision]:
        &#34;&#34;&#34;
        Process a perception and make a decision.

        Args:
            perception (Union[Perception, Dict[str, Any]]): The perception to process, can be a Perception object or a dictionary.

        Returns:
            Decision: The decision made based on the perception.
        &#34;&#34;&#34;
        if not self.is_ready():
            logger.warning(&#34;Framer is not ready. Queuing perception.&#34;)
            self.perceptions_queue.append(perception)
            return None  # Return None to indicate the perception was queued
        &#34;&#34;&#34;
        Process a perception and make a decision.

        Args:
            perception (Union[Perception, Dict[str, Any]]): The perception to process, can be a Perception object or a dictionary.

        Returns:
            Decision: The decision made based on the perception.
        &#34;&#34;&#34;
        if not self.plugin_loading_complete or not self.acting:
            logger.warning(&#34;Framer is not ready. Queuing perception.&#34;)
            self.perceptions_queue.append(perception)
            return None  # Return None to indicate the perception was queued
        # Convert perception to Perception object if it is a dictionary
        if isinstance(perception, dict):
            perception = Perception.from_dict(perception)
        current_goals = self.agency.get_goals()
        decision = await self.brain.process_perception(perception, current_goals)

        # Consider goal status in decision-making
        active_goals = [
            goal for goal in current_goals if goal.status == GoalStatus.ACTIVE
        ]
        if active_goals:
            decision.reasoning += f&#34; (Aligned with {len(active_goals)} active goals)&#34;

        if hasattr(self, &#34;can_execute&#34;) and self.can_execute:
            await self.brain.execute_decision(decision)
        logger.debug(f&#34;Processed perception: {perception}, Decision: {decision}&#34;)
        self.notify_observers(decision)
        return decision  

    async def prompt(self, text: str) -&gt; Decision:
        &#34;&#34;&#34;
        Process a prompt as a new perception of type &#39;hearing&#39;.

        Args:
            text (str): The text of the prompt.

        Returns:
            Decision: The decision made based on the prompt.
        &#34;&#34;&#34;
        perception_dict = {&#34;type&#34;: &#34;hearing&#34;, &#34;data&#34;: {&#34;text&#34;: text}}
        perception = Perception.from_dict(perception_dict)
        return await self.sense(perception)

    def add_observer(self, observer: Observer) -&gt; None:
        &#34;&#34;&#34;
        Add an observer to be notified when a decision is made.

        Args:
            observer (Observer): The observer function to add.
        &#34;&#34;&#34;
        self.observers.append(observer)

    def remove_observer(self, observer: Observer) -&gt; None:
        &#34;&#34;&#34;
        Remove an observer.

        Args:
            observer (Observer): The observer function to remove.
        &#34;&#34;&#34;
        self.observers.remove(observer)

    def notify_observers(self, decision: Decision) -&gt; None:
        &#34;&#34;&#34;
        Notify all observers about a decision.

        Args:
            decision (Decision): The decision to notify observers about.
        &#34;&#34;&#34;
        for observer in self.observers:
            observer(decision)

        # Notify plugins about the decision
        for plugin in self.plugins.values():
            if hasattr(plugin, &#34;on_decision_made&#34;):
                plugin.on_decision_made(decision)

    async def generate_tasks_from_perception(
        self,
        perception: Union[Perception, Dict[str, Any]],
        max_len: Optional[int] = None,
    ) -&gt; List[Task]:
        &#34;&#34;&#34;
        Generate tasks based on the given perception.

        Args:
            perception (Union[Perception, Dict[str, Any]]): The perception to generate tasks from.
            max_len (Optional[int]): Maximum number of tasks to generate. If None, no limit is applied.

        Returns:
            List[Task]: A list of generated tasks.
        &#34;&#34;&#34;
        tasks = []

        # Convert dictionary to Perception object if necessary
        if isinstance(perception, dict):
            perception = Perception.from_dict(perception)

        # Example: Create a task to process the perception
        task = Task(
            description=f&#34;Process perception of type: {perception.type}&#34;,
            workflow_id=&#34;perception_processing&#34;,
        )
        tasks.append(task)

        # Add more sophisticated logic here to generate tasks based on the perception content
        # For example, you could analyze the perception data and create specific tasks

        # Limit the number of tasks if max_len is specified
        if max_len is not None:
            tasks = tasks[:max_len]

        return tasks

    async def close(self) -&gt; None:
        &#34;&#34;&#34;
        Optimize and clear all memory for the Framer.

        This method ensures that all tasks and workflows are closed properly,
        and any resources or memory used by the Framer are released. It is
        important to call this method when the Framer is no longer needed to
        prevent memory leaks and ensure optimal performance. This method
        should be called to gracefully shut down the Framer.
        &#34;&#34;&#34;
        # Close all workflows
        for workflow in self.workflow_manager.workflows.values():
            workflow.set_final_task(
                Task(description=&#34;Final Task&#34;)
            )  # Set a default final task
            for task in workflow.tasks:
                task.update_status(TaskStatus.COMPLETED)  # Mark tasks as completed

        # Clear memory
        if self.memory_service and hasattr(self.memory_service, &#34;clear&#34;):
            self.memory_service.clear()

        # Notify observers and plugins about closure and opening
        for observer in self.observers:
            if hasattr(observer, &#34;on_framer_closed&#34;):
                observer.on_framer_closed(self)

        if hasattr(self, &#34;plugins&#34;):
            for plugin in self.plugins.values():
                if hasattr(plugin, &#34;on_framer_closed&#34;):
                    plugin.on_framer_closed(self)</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="frame.src.framer.Framer.perceptions_queue"><code class="name">var <span class="ident">perceptions_queue</span> : Deque[Union[<a title="frame.src.framer.brain.perception.perception.Perception" href="brain/perception/perception.html#frame.src.framer.brain.perception.perception.Perception">Perception</a>, Dict[str, Any]]]</code></dt>
<dd>
<div class="desc"><p>The Framer class represents an AI agent with cognitive capabilities. It integrates various components
such as agency, brain, soul, and workflow management to create a comprehensive AI entity capable of
processing perceptions, making decisions, and executing tasks.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>config</code></strong> :&ensp;<code><a title="frame.src.framer.FramerConfig" href="#frame.src.framer.FramerConfig">FramerConfig</a></code></dt>
<dd>Configuration settings for the Framer.</dd>
<dt><strong><code>llm_service</code></strong> :&ensp;<code>LLMService</code></dt>
<dd>The language model service to be used by the Framer.</dd>
<dt><strong><code>agency</code></strong> :&ensp;<code>Agency</code></dt>
<dd>Manages roles, goals, tasks, and workflows for the Framer.</dd>
<dt><strong><code>brain</code></strong> :&ensp;<code>Brain</code></dt>
<dd>Handles decision-making processes, integrating perceptions, memories, and thoughts.</dd>
<dt><strong><code>soul</code></strong> :&ensp;<code>Soul</code></dt>
<dd>Represents the core essence and personality of a Framer.</dd>
<dt><strong><code>workflow_manager</code></strong> :&ensp;<code>WorkflowManager</code></dt>
<dd>Manages workflows and tasks.</dd>
<dt><strong><code>memory_service</code></strong> :&ensp;<code>Optional[MemoryService]</code></dt>
<dd>Service for managing memory. Default is None.</dd>
<dt><strong><code>eq_service</code></strong> :&ensp;<code>Optional[EQService]</code></dt>
<dd>Service for managing emotional intelligence. Default is None.</dd>
<dt><strong><code>roles</code></strong> :&ensp;<code>Optional[List[Dict[str, Any]]]</code></dt>
<dd>List of roles for the Framer. Default is None.</dd>
<dt><strong><code>goals</code></strong> :&ensp;<code>Optional[List[Dict[str, Any]]]</code></dt>
<dd>List of goals for the Framer. Default is None.</dd>
<dt><strong><code>observers</code></strong> :&ensp;<code>List[Observer]</code></dt>
<dd>List of observer functions to notify on decisions.</dd>
<dt><strong><code>can_execute</code></strong> :&ensp;<code>bool</code></dt>
<dd>Determines if decisions are executed automatically. Default is True.</dd>
<dt><strong><code>acting</code></strong> :&ensp;<code>bool</code></dt>
<dd>Indicates if the Framer is actively processing perceptions. Default is False.</dd>
</dl></div>
</dd>
</dl>
<h3>Static methods</h3>
<dl>
<dt id="frame.src.framer.Framer.load_from_file"><code class="name flex">
<span>def <span class="ident">load_from_file</span></span>(<span>file_path: str, llm_service: <a title="frame.src.services.llm.main.LLMService" href="../services/llm/main.html#frame.src.services.llm.main.LLMService">LLMService</a>, memory_service: Optional[<a title="frame.src.services.memory.main.MemoryService" href="../services/memory/main.html#frame.src.services.memory.main.MemoryService">MemoryService</a>] = None, eq_service: Optional[<a title="frame.src.services.eq.main.EQService" href="../services/eq/main.html#frame.src.services.eq.main.EQService">EQService</a>] = None) ‑> <a title="frame.src.framer.framer.Framer" href="framer.html#frame.src.framer.framer.Framer">Framer</a></span>
</code></dt>
<dd>
<div class="desc"><p>Load a Framer configuration from a file.</p>
<p>This method allows importing a Framer agent from a JSON or markdown file,
enabling the reconstruction of the agent's state and configuration. This
functionality is crucial for restoring Framer agents from saved states,
ensuring continuity and consistency across different sessions or environments.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>file_path</code></strong> :&ensp;<code>str</code></dt>
<dd>The path to the configuration file.</dd>
<dt><strong><code>llm_service</code></strong> :&ensp;<code>LLMService</code></dt>
<dd>Language model service.</dd>
<dt><strong><code>memory_service</code></strong> :&ensp;<code>Optional[MemoryService]</code></dt>
<dd>Memory service for the Framer.</dd>
<dt><strong><code>eq_service</code></strong> :&ensp;<code>Optional[EQService]</code></dt>
<dd>Emotional intelligence service for the Framer.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="frame.src.framer.Framer" href="#frame.src.framer.Framer">Framer</a></code></dt>
<dd>A new Framer instance configured from the file.</dd>
</dl></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="frame.src.framer.Framer.act"><code class="name flex">
<span>def <span class="ident">act</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Enable the Framer to start acting and processing perceptions.</p></div>
</dd>
<dt id="frame.src.framer.Framer.add_observer"><code class="name flex">
<span>def <span class="ident">add_observer</span></span>(<span>self, observer: Callable[[<a title="frame.src.framer.brain.decision.decision.Decision" href="brain/decision/decision.html#frame.src.framer.brain.decision.decision.Decision">Decision</a>], None]) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Add an observer to be notified when a decision is made.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>observer</code></strong> :&ensp;<code>Observer</code></dt>
<dd>The observer function to add.</dd>
</dl></div>
</dd>
<dt id="frame.src.framer.Framer.close"><code class="name flex">
<span>async def <span class="ident">close</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Optimize and clear all memory for the Framer.</p>
<p>This method ensures that all tasks and workflows are closed properly,
and any resources or memory used by the Framer are released. It is
important to call this method when the Framer is no longer needed to
prevent memory leaks and ensure optimal performance. This method
should be called to gracefully shut down the Framer.</p></div>
</dd>
<dt id="frame.src.framer.Framer.export_to_file"><code class="name flex">
<span>async def <span class="ident">export_to_file</span></span>(<span>self, file_path: str, llm) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Export the Framer configuration to a JSON file.</p>
<p>This method allows the Framer agent to be fully exported into a JSON format,
making it portable and easy to use inside a prompt to any other LLM. This
portability enables the Framer agents to be shared and consumed by other
systems, facilitating interoperability and reuse.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>file_path</code></strong> :&ensp;<code>str</code></dt>
<dd>The path to the file where the JSON will be saved.</dd>
</dl></div>
</dd>
<dt id="frame.src.framer.Framer.export_to_markdown"><code class="name flex">
<span>def <span class="ident">export_to_markdown</span></span>(<span>self, file_path: str) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Export the Framer configuration to a Markdown file.</p>
<p>This method allows the Framer agent to be fully exported into a Markdown format,
making it portable and easy to use inside a prompt to any other LLM. This
portability enables the Framer agents to be shared and consumed by other
systems, facilitating interoperability and reuse.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>file_path</code></strong> :&ensp;<code>str</code></dt>
<dd>The path to the file where the Markdown will be saved.</dd>
</dl></div>
</dd>
<dt id="frame.src.framer.Framer.generate_tasks_from_perception"><code class="name flex">
<span>async def <span class="ident">generate_tasks_from_perception</span></span>(<span>self, perception: Union[<a title="frame.src.framer.brain.perception.perception.Perception" href="brain/perception/perception.html#frame.src.framer.brain.perception.perception.Perception">Perception</a>, Dict[str, Any]], max_len: Optional[int] = None) ‑> List[<a title="frame.src.framer.agency.tasks.task.Task" href="agency/tasks/task.html#frame.src.framer.agency.tasks.task.Task">Task</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Generate tasks based on the given perception.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>perception</code></strong> :&ensp;<code>Union[Perception, Dict[str, Any]]</code></dt>
<dd>The perception to generate tasks from.</dd>
<dt><strong><code>max_len</code></strong> :&ensp;<code>Optional[int]</code></dt>
<dd>Maximum number of tasks to generate. If None, no limit is applied.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>List[Task]</code></dt>
<dd>A list of generated tasks.</dd>
</dl></div>
</dd>
<dt id="frame.src.framer.Framer.is_ready"><code class="name flex">
<span>def <span class="ident">is_ready</span></span>(<span>self) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Check if the Framer is ready to process perceptions and make decisions.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>True if the Framer is ready, False otherwise.</dd>
</dl></div>
</dd>
<dt id="frame.src.framer.Framer.load_plugins"><code class="name flex">
<span>async def <span class="ident">load_plugins</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Load all plugins by calling their on_load method.</p></div>
</dd>
<dt id="frame.src.framer.Framer.notify_observers"><code class="name flex">
<span>def <span class="ident">notify_observers</span></span>(<span>self, decision: <a title="frame.src.framer.brain.decision.decision.Decision" href="brain/decision/decision.html#frame.src.framer.brain.decision.decision.Decision">Decision</a>) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Notify all observers about a decision.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>decision</code></strong> :&ensp;<code>Decision</code></dt>
<dd>The decision to notify observers about.</dd>
</dl></div>
</dd>
<dt id="frame.src.framer.Framer.perform_task"><code class="name flex">
<span>async def <span class="ident">perform_task</span></span>(<span>self, task: Dict[str, Any]) ‑> Dict[str, Any]</span>
</code></dt>
<dd>
<div class="desc"><p>Perform a task asynchronously.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>task</code></strong> :&ensp;<code>Dict[str, Any]</code></dt>
<dd>Dictionary containing task details.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Dict[str, Any]</code></dt>
<dd>Result of the task execution.</dd>
</dl></div>
</dd>
<dt id="frame.src.framer.Framer.process_queued_perceptions"><code class="name flex">
<span>async def <span class="ident">process_queued_perceptions</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Process all queued perceptions once the Framer is ready.</p></div>
</dd>
<dt id="frame.src.framer.Framer.prompt"><code class="name flex">
<span>async def <span class="ident">prompt</span></span>(<span>self, text: str) ‑> <a title="frame.src.framer.brain.decision.decision.Decision" href="brain/decision/decision.html#frame.src.framer.brain.decision.decision.Decision">Decision</a></span>
</code></dt>
<dd>
<div class="desc"><p>Process a prompt as a new perception of type 'hearing'.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>text</code></strong> :&ensp;<code>str</code></dt>
<dd>The text of the prompt.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Decision</code></dt>
<dd>The decision made based on the prompt.</dd>
</dl></div>
</dd>
<dt id="frame.src.framer.Framer.remove_observer"><code class="name flex">
<span>def <span class="ident">remove_observer</span></span>(<span>self, observer: Callable[[<a title="frame.src.framer.brain.decision.decision.Decision" href="brain/decision/decision.html#frame.src.framer.brain.decision.decision.Decision">Decision</a>], None]) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Remove an observer.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>observer</code></strong> :&ensp;<code>Observer</code></dt>
<dd>The observer function to remove.</dd>
</dl></div>
</dd>
<dt id="frame.src.framer.Framer.sense"><code class="name flex">
<span>async def <span class="ident">sense</span></span>(<span>self, perception: Union[<a title="frame.src.framer.brain.perception.perception.Perception" href="brain/perception/perception.html#frame.src.framer.brain.perception.perception.Perception">Perception</a>, Dict[str, Any]]) ‑> Optional[<a title="frame.src.framer.brain.decision.decision.Decision" href="brain/decision/decision.html#frame.src.framer.brain.decision.decision.Decision">Decision</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Process a perception and make a decision.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>perception</code></strong> :&ensp;<code>Union[Perception, Dict[str, Any]]</code></dt>
<dd>The perception to process, can be a Perception object or a dictionary.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Decision</code></dt>
<dd>The decision made based on the perception.</dd>
</dl></div>
</dd>
<dt id="frame.src.framer.Framer.use_plugin_action"><code class="name flex">
<span>async def <span class="ident">use_plugin_action</span></span>(<span>self, plugin_name: str, action_name: str, parameters: Dict[str, Any]) ‑> Any</span>
</code></dt>
<dd>
<div class="desc"><p>Execute a plugin action directly.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>plugin_name</code></strong> :&ensp;<code>str</code></dt>
<dd>The name of the plugin.</dd>
<dt><strong><code>action_name</code></strong> :&ensp;<code>str</code></dt>
<dd>The name of the action to execute.</dd>
<dt><strong><code>parameters</code></strong> :&ensp;<code>Dict[str, Any]</code></dt>
<dd>Parameters for the action.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Any</code></dt>
<dd>The result of the action execution.</dd>
</dl></div>
</dd>
</dl>
</dd>
<dt id="frame.src.framer.FramerConfig"><code class="flex name class">
<span>class <span class="ident">FramerConfig</span></span>
<span>(</span><span>**data)</span>
</code></dt>
<dd>
<div class="desc"><p>Usage docs: <a href="https://docs.pydantic.dev/2.9/concepts/models/">https://docs.pydantic.dev/2.9/concepts/models/</a></p>
<p>A base class for creating Pydantic models.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>__class_vars__</code></strong></dt>
<dd>The names of the class variables defined on the model.</dd>
<dt><strong><code>__private_attributes__</code></strong></dt>
<dd>Metadata about the private attributes of the model.</dd>
<dt><strong><code>__signature__</code></strong></dt>
<dd>The synthesized <code>__init__</code> [<code>Signature</code>][inspect.Signature] of the model.</dd>
<dt><strong><code>__pydantic_complete__</code></strong></dt>
<dd>Whether model building is completed, or if there are still undefined fields.</dd>
<dt><strong><code>__pydantic_core_schema__</code></strong></dt>
<dd>The core schema of the model.</dd>
<dt><strong><code>__pydantic_custom_init__</code></strong></dt>
<dd>Whether the model has a custom <code>__init__</code> function.</dd>
<dt><strong><code>__pydantic_decorators__</code></strong></dt>
<dd>Metadata containing the decorators defined on the model.
This replaces <code>Model.__validators__</code> and <code>Model.__root_validators__</code> from Pydantic V1.</dd>
<dt><strong><code>__pydantic_generic_metadata__</code></strong></dt>
<dd>Metadata for generic models; contains data used for a similar purpose to
<strong>args</strong>, <strong>origin</strong>, <strong>parameters</strong> in typing-module generics. May eventually be replaced by these.</dd>
<dt><strong><code>__pydantic_parent_namespace__</code></strong></dt>
<dd>Parent namespace of the model, used for automatic rebuilding of models.</dd>
<dt><strong><code>__pydantic_post_init__</code></strong></dt>
<dd>The name of the post-init method for the model, if defined.</dd>
<dt><strong><code>__pydantic_root_model__</code></strong></dt>
<dd>Whether the model is a [<code>RootModel</code>][pydantic.root_model.RootModel].</dd>
<dt><strong><code>__pydantic_serializer__</code></strong></dt>
<dd>The <code>pydantic-core</code> <code>SchemaSerializer</code> used to dump instances of the model.</dd>
<dt><strong><code>__pydantic_validator__</code></strong></dt>
<dd>The <code>pydantic-core</code> <code>SchemaValidator</code> used to validate instances of the model.</dd>
<dt><strong><code>__pydantic_extra__</code></strong></dt>
<dd>A dictionary containing extra values, if [<code>extra</code>][pydantic.config.ConfigDict.extra]
is set to <code>'allow'</code>.</dd>
<dt><strong><code>__pydantic_fields_set__</code></strong></dt>
<dd>The names of fields explicitly set during instantiation.</dd>
<dt><strong><code>__pydantic_private__</code></strong></dt>
<dd>Values of private attributes set on the model instance.</dd>
</dl>
<p>Create a new model by parsing and validating input data from keyword arguments.</p>
<p>Raises [<code>ValidationError</code>][pydantic_core.ValidationError] if the input data cannot be
validated to form a valid model.</p>
<p><code>self</code> is explicitly positional-only to allow <code>self</code> as a field name.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FramerConfig(BaseModel):
    name: str
    model: Optional[str] = None
    soul_seed: Optional[Union[str, Dict[str, Any]]] = &#34;You are a helpful AI assistant.&#34;
    use_local_model: bool = False
    # Default permissions include services like memory, eq, and shared_context.
    # These services do not require explicit permissions to be accessed.
    permissions: Optional[List[str]] = Field(default_factory=lambda: [&#34;with_memory&#34;, &#34;with_mem0_search_extract_summarize_plugin&#34;, &#34;with_shared_context&#34;])
    mem0_api_key: Optional[str] = MEM0_API_KEY
    &#34;&#34;&#34;
    Configuration class for Framer instances.

    This class initializes a Framer configuration based on a dictionary of settings.
    It uses the FramerConfigModel to validate and set default values for the configuration.

    Attributes:
        name (str): The name of the Framer.
        description (Optional[str]): The description of the Framer.
        singleton (Optional[bool]): Whether the Framer is a singleton instance.
        gender (Optional[str]): The gender of the Framer.
        default_model (Optional[str]): The default language model to use.
        multi_modal_model (Optional[str]): The multi-modal model to use.
        llm_temperature (Optional[float]): The temperature setting for language model responses.
        llm_max_tokens (Optional[int]): The maximum number of tokens for language model responses.
        llm_top_p (Optional[float]): The top_p setting for language model responses.
        llm_frequency_penalty (Optional[float]): The frequency penalty for language model responses.
        llm_presence_penalty (Optional[float]): The presence penalty for language model responses.
        is_multi_modal (Optional[bool]): Indicates if multi-modal capabilities are enabled.
        roles (Optional[List[Dict[str, str]]]): The roles for the Framer.
        goals (Optional[List[Dict[str, Any]]]): The goals for the Framer.
    &#34;&#34;&#34;

    description: Optional[str] = None
    singleton: Optional[bool] = False
    gender: Optional[str] = &#34;neutral&#34;
    default_model: Optional[str] = &#34;gpt-4o-mini&#34;
    multi_modal_model: Optional[str] = &#34;gpt-4-vision-preview&#34;
    llm_temperature: Optional[float] = 0.7
    llm_max_tokens: Optional[int] = 1024
    llm_top_p: Optional[float] = 1.0
    llm_frequency_penalty: Optional[float] = 0.0
    llm_presence_penalty: Optional[float] = 0.0
    is_multi_modal: Optional[bool] = False
    roles: Optional[List[Dict[str, Any]]] = None
    goals: Optional[List[Dict[str, Any]]] = None
    recent_memories_limit: Optional[int] = 5

    def get(self, key: str, default: Any = None) -&gt; Any:
        &#34;&#34;&#34;
        Retrieve the value of a configuration attribute safely.

        Args:
            key (str): The attribute name to retrieve.
            default (Any): The default value to return if the attribute is not found.

        Returns:
            Any: The value of the attribute if it exists, otherwise the default value.
        &#34;&#34;&#34;
        return getattr(self, key, default)

    def __init__(self, **data):
        super().__init__(**data)
        if self.default_model:
            self.default_model = self.default_model.lower()
        if self.use_local_model and not HUGGINGFACE_API_KEY.strip():
            logger = get_logger(__name__)
            logger.error(
                &#34;Error: Hugging Face API key is not set, but the Framer is set to use local models. Some features may not work.&#34;
            )</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>pydantic.main.BaseModel</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="frame.src.framer.FramerConfig.default_model"><code class="name">var <span class="ident">default_model</span> : Optional[str]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="frame.src.framer.FramerConfig.description"><code class="name">var <span class="ident">description</span> : Optional[str]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="frame.src.framer.FramerConfig.gender"><code class="name">var <span class="ident">gender</span> : Optional[str]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="frame.src.framer.FramerConfig.goals"><code class="name">var <span class="ident">goals</span> : Optional[List[Dict[str, Any]]]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="frame.src.framer.FramerConfig.is_multi_modal"><code class="name">var <span class="ident">is_multi_modal</span> : Optional[bool]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="frame.src.framer.FramerConfig.llm_frequency_penalty"><code class="name">var <span class="ident">llm_frequency_penalty</span> : Optional[float]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="frame.src.framer.FramerConfig.llm_max_tokens"><code class="name">var <span class="ident">llm_max_tokens</span> : Optional[int]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="frame.src.framer.FramerConfig.llm_presence_penalty"><code class="name">var <span class="ident">llm_presence_penalty</span> : Optional[float]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="frame.src.framer.FramerConfig.llm_temperature"><code class="name">var <span class="ident">llm_temperature</span> : Optional[float]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="frame.src.framer.FramerConfig.llm_top_p"><code class="name">var <span class="ident">llm_top_p</span> : Optional[float]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="frame.src.framer.FramerConfig.mem0_api_key"><code class="name">var <span class="ident">mem0_api_key</span> : Optional[str]</code></dt>
<dd>
<div class="desc"><p>Configuration class for Framer instances.</p>
<p>This class initializes a Framer configuration based on a dictionary of settings.
It uses the FramerConfigModel to validate and set default values for the configuration.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>The name of the Framer.</dd>
<dt><strong><code>description</code></strong> :&ensp;<code>Optional[str]</code></dt>
<dd>The description of the Framer.</dd>
<dt><strong><code>singleton</code></strong> :&ensp;<code>Optional[bool]</code></dt>
<dd>Whether the Framer is a singleton instance.</dd>
<dt><strong><code>gender</code></strong> :&ensp;<code>Optional[str]</code></dt>
<dd>The gender of the Framer.</dd>
<dt><strong><code>default_model</code></strong> :&ensp;<code>Optional[str]</code></dt>
<dd>The default language model to use.</dd>
<dt><strong><code>multi_modal_model</code></strong> :&ensp;<code>Optional[str]</code></dt>
<dd>The multi-modal model to use.</dd>
<dt><strong><code>llm_temperature</code></strong> :&ensp;<code>Optional[float]</code></dt>
<dd>The temperature setting for language model responses.</dd>
<dt><strong><code>llm_max_tokens</code></strong> :&ensp;<code>Optional[int]</code></dt>
<dd>The maximum number of tokens for language model responses.</dd>
<dt><strong><code>llm_top_p</code></strong> :&ensp;<code>Optional[float]</code></dt>
<dd>The top_p setting for language model responses.</dd>
<dt><strong><code>llm_frequency_penalty</code></strong> :&ensp;<code>Optional[float]</code></dt>
<dd>The frequency penalty for language model responses.</dd>
<dt><strong><code>llm_presence_penalty</code></strong> :&ensp;<code>Optional[float]</code></dt>
<dd>The presence penalty for language model responses.</dd>
<dt><strong><code>is_multi_modal</code></strong> :&ensp;<code>Optional[bool]</code></dt>
<dd>Indicates if multi-modal capabilities are enabled.</dd>
<dt><strong><code>roles</code></strong> :&ensp;<code>Optional[List[Dict[str, str]]]</code></dt>
<dd>The roles for the Framer.</dd>
<dt><strong><code>goals</code></strong> :&ensp;<code>Optional[List[Dict[str, Any]]]</code></dt>
<dd>The goals for the Framer.</dd>
</dl></div>
</dd>
<dt id="frame.src.framer.FramerConfig.model"><code class="name">var <span class="ident">model</span> : Optional[str]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="frame.src.framer.FramerConfig.model_computed_fields"><code class="name">var <span class="ident">model_computed_fields</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="frame.src.framer.FramerConfig.model_config"><code class="name">var <span class="ident">model_config</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="frame.src.framer.FramerConfig.model_fields"><code class="name">var <span class="ident">model_fields</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="frame.src.framer.FramerConfig.multi_modal_model"><code class="name">var <span class="ident">multi_modal_model</span> : Optional[str]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="frame.src.framer.FramerConfig.name"><code class="name">var <span class="ident">name</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="frame.src.framer.FramerConfig.permissions"><code class="name">var <span class="ident">permissions</span> : Optional[List[str]]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="frame.src.framer.FramerConfig.recent_memories_limit"><code class="name">var <span class="ident">recent_memories_limit</span> : Optional[int]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="frame.src.framer.FramerConfig.roles"><code class="name">var <span class="ident">roles</span> : Optional[List[Dict[str, Any]]]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="frame.src.framer.FramerConfig.singleton"><code class="name">var <span class="ident">singleton</span> : Optional[bool]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="frame.src.framer.FramerConfig.soul_seed"><code class="name">var <span class="ident">soul_seed</span> : Union[str, Dict[str, Any], ForwardRef(None)]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="frame.src.framer.FramerConfig.use_local_model"><code class="name">var <span class="ident">use_local_model</span> : bool</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="frame.src.framer.FramerConfig.get"><code class="name flex">
<span>def <span class="ident">get</span></span>(<span>self, key: str, default: Any = None) ‑> Any</span>
</code></dt>
<dd>
<div class="desc"><p>Retrieve the value of a configuration attribute safely.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>key</code></strong> :&ensp;<code>str</code></dt>
<dd>The attribute name to retrieve.</dd>
<dt><strong><code>default</code></strong> :&ensp;<code>Any</code></dt>
<dd>The default value to return if the attribute is not found.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Any</code></dt>
<dd>The value of the attribute if it exists, otherwise the default value.</dd>
</dl></div>
</dd>
</dl>
</dd>
<dt id="frame.src.framer.FramerFactory"><code class="flex name class">
<span>class <span class="ident">FramerFactory</span></span>
<span>(</span><span>config: <a title="frame.src.framer.config.FramerConfig" href="config.html#frame.src.framer.config.FramerConfig">FramerConfig</a>, llm_service: <a title="frame.src.services.llm.main.LLMService" href="../services/llm/main.html#frame.src.services.llm.main.LLMService">LLMService</a>, plugins: Optional[Dict[str, Any]] = [])</span>
</code></dt>
<dd>
<div class="desc"><p>Factory class for creating Framer instances.</p>
<p>This class encapsulates the logic for constructing Framer objects,
ensuring that all necessary components are properly initialized.</p>
<p>The Framer includes a <code>halt()</code> method to stop its actions and task processing.</p>
<p>The FramerFactory supports the creation of Framers with custom plugins,
allowing for extensive customization and expansion of capabilities.
This plugin system is designed to be as flexible and powerful as mods in games,
enabling developers to create a wide range of extensions and enhancements.</p>
<p>Initialize the FramerBuilder with configuration and LLM service.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>config</code></strong> :&ensp;<code><a title="frame.src.framer.FramerConfig" href="#frame.src.framer.FramerConfig">FramerConfig</a></code></dt>
<dd>Configuration for the Framer.</dd>
<dt><strong><code>llm_service</code></strong> :&ensp;<code>LLMService</code></dt>
<dd>Language model service for text generation.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FramerFactory:
    &#34;&#34;&#34;
    Factory class for creating Framer instances.

    This class encapsulates the logic for constructing Framer objects,
    ensuring that all necessary components are properly initialized.

    The Framer includes a `halt()` method to stop its actions and task processing.

    The FramerFactory supports the creation of Framers with custom plugins,
    allowing for extensive customization and expansion of capabilities.
    This plugin system is designed to be as flexible and powerful as mods in games,
    enabling developers to create a wide range of extensions and enhancements.
    &#34;&#34;&#34;

    def __init__(self, config: FramerConfig, llm_service: LLMService, plugins: Optional[Dict[str, Any]] = []):
        &#34;&#34;&#34;
        Initialize the FramerBuilder with configuration and LLM service.

        Args:
            config (FramerConfig): Configuration for the Framer.
            llm_service (LLMService): Language model service for text generation.
        &#34;&#34;&#34;
        &#34;&#34;&#34;
        Initialize the FramerFactory with configuration and LLM service.

        Args:
            config (FramerConfig): Configuration for the Framer.
            llm_service (LLMService): Language model service for text generation.
        &#34;&#34;&#34;
        if not isinstance(config, FramerConfig):
            raise TypeError(&#34;config must be an instance of FramerConfig&#34;)
        if not isinstance(llm_service, LLMService):
            raise TypeError(&#34;llm_service must be an instance of LLMService&#34;)
        self.logger = logging.getLogger(__name__)
        self.config = config
        self.llm_service = llm_service
        self.plugins = plugins

    async def create_framer(
        self,
        memory_service: Optional[MemoryService] = None,
        eq_service: Optional[EQService] = None,
        roles: Optional[List[Role]] = None,
        goals: Optional[List[Goal]] = None,
        plugins: Optional[Dict[str, Any]] = None,
    ) -&gt; Framer:
        self.plugins = plugins or {}
        execution_context = ExecutionContext(llm_service=self.llm_service)
        agency = Agency(
            llm_service=self.llm_service,
            execution_context=execution_context,
            context=None,
        )
        # Initialize the Agency component with default permissions
        self.config.permissions = self.config.permissions or [&#34;with_memory&#34;, &#34;with_mem0_search_extract_summarize_plugin&#34;, &#34;with_shared_context&#34;]
        roles, goals = await self._generate_roles_and_goals(agency, roles, goals)
        brain = Brain(
            # Initialize the Brain component with roles, goals, and default model
            llm_service=self.llm_service,
            roles=roles,
            goals=goals,
            default_model=(
                self.config.default_model
                if self.config.default_model
                else DEFAULT_MODEL
            ),
        )
        # Initialize the Soul component with the provided or default seed
        soul = Soul(seed=self.config.soul_seed)
        # Initialize the WorkflowManager component
        workflow_manager = WorkflowManager()
        # Set the memory service if provided, otherwise create a new one
        memory_service = memory_service or MemoryService(adapter=Mem0Adapter())

        framer = Framer(
            config=self.config,
            llm_service=self.llm_service,
            agency=agency,
            brain=brain,
            soul=soul,
            workflow_manager=workflow_manager,
            memory_service=memory_service,
            eq_service=eq_service,
            plugins=plugins
        )

        framer.agency.set_goals(goals)
        framer.agency.set_roles(roles)

        # Set the Framer instance in Brain and ActionRegistry
        framer.brain.set_framer(framer)
        framer.brain.agency.action_registry.set_framer(framer)

        # Notify observers about the Framer being opened
        for observer in framer.observers:
            if hasattr(observer, &#34;on_framer_opened&#34;):
                observer.on_framer_opened(framer)

        # Call on_load for each plugin
        for plugin_name, plugin_instance in framer.plugins.items():
            if hasattr(plugin_instance, &#34;on_load&#34;):
                self.logger.info(f&#34;Loading plugin: {plugin_name}&#34;)
                await plugin_instance.on_load(framer)
                self.logger.info(f&#34;Plugin {plugin_name} loaded successfully.&#34;)

        framer.plugin_loading_complete = True

        return framer

    async def _generate_roles_and_goals(self, agency, roles, goals):
        if roles is None or goals is None:
            roles, goals = await agency.generate_roles_and_goals()
        elif isinstance(roles, list) and len(roles) == 0:
            roles = []
            goals = []
        elif isinstance(goals, list) and len(goals) == 0:
            roles, goals = await agency.generate_roles_and_goals()
            goals = []
        elif isinstance(roles, list) and len(roles) == 0 and goals:
            roles, new_goals = await agency.generate_roles_and_goals()
            goals.extend(new_goals)

        # Ensure goals have a default status of ACTIVE
        for goal in goals:
            if isinstance(goal, dict):
                if &#34;status&#34; not in goal:
                    goal[&#34;status&#34;] = GoalStatus.ACTIVE.value
            else:
                goal.status = GoalStatus.ACTIVE
        for role in roles:
            if isinstance(role, dict):
                if &#34;status&#34; not in role:
                    role[&#34;status&#34;] = RoleStatus.ACTIVE.value
            else:
                role.status = RoleStatus.ACTIVE

        # Sort roles and goals by priority
        roles.sort(key=lambda x: x.priority.value if hasattr(x, &#39;priority&#39;) else 5, reverse=True)
        goals.sort(key=lambda x: x.priority.value if hasattr(x, &#39;priority&#39;) else 5, reverse=True)

        return roles, goals</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="frame.src.framer.FramerFactory.create_framer"><code class="name flex">
<span>async def <span class="ident">create_framer</span></span>(<span>self, memory_service: Optional[<a title="frame.src.services.memory.main.MemoryService" href="../services/memory/main.html#frame.src.services.memory.main.MemoryService">MemoryService</a>] = None, eq_service: Optional[<a title="frame.src.services.eq.main.EQService" href="../services/eq/main.html#frame.src.services.eq.main.EQService">EQService</a>] = None, roles: Optional[List[<a title="frame.src.framer.agency.roles.Role" href="agency/roles.html#frame.src.framer.agency.roles.Role">Role</a>]] = None, goals: Optional[List[<a title="frame.src.framer.agency.goals.Goal" href="agency/goals.html#frame.src.framer.agency.goals.Goal">Goal</a>]] = None, plugins: Optional[Dict[str, Any]] = None) ‑> <a title="frame.src.framer.framer.Framer" href="framer.html#frame.src.framer.framer.Framer">Framer</a></span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="frame.src" href="../index.html">frame.src</a></code></li>
</ul>
</li>
<li><h3><a href="#header-submodules">Sub-modules</a></h3>
<ul>
<li><code><a title="frame.src.framer.agency" href="agency/index.html">frame.src.framer.agency</a></code></li>
<li><code><a title="frame.src.framer.brain" href="brain/index.html">frame.src.framer.brain</a></code></li>
<li><code><a title="frame.src.framer.config" href="config.html">frame.src.framer.config</a></code></li>
<li><code><a title="frame.src.framer.framer" href="framer.html">frame.src.framer.framer</a></code></li>
<li><code><a title="frame.src.framer.framer_factory" href="framer_factory.html">frame.src.framer.framer_factory</a></code></li>
<li><code><a title="frame.src.framer.soul" href="soul/index.html">frame.src.framer.soul</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="frame.src.framer.Framer" href="#frame.src.framer.Framer">Framer</a></code></h4>
<ul class="">
<li><code><a title="frame.src.framer.Framer.act" href="#frame.src.framer.Framer.act">act</a></code></li>
<li><code><a title="frame.src.framer.Framer.add_observer" href="#frame.src.framer.Framer.add_observer">add_observer</a></code></li>
<li><code><a title="frame.src.framer.Framer.close" href="#frame.src.framer.Framer.close">close</a></code></li>
<li><code><a title="frame.src.framer.Framer.export_to_file" href="#frame.src.framer.Framer.export_to_file">export_to_file</a></code></li>
<li><code><a title="frame.src.framer.Framer.export_to_markdown" href="#frame.src.framer.Framer.export_to_markdown">export_to_markdown</a></code></li>
<li><code><a title="frame.src.framer.Framer.generate_tasks_from_perception" href="#frame.src.framer.Framer.generate_tasks_from_perception">generate_tasks_from_perception</a></code></li>
<li><code><a title="frame.src.framer.Framer.is_ready" href="#frame.src.framer.Framer.is_ready">is_ready</a></code></li>
<li><code><a title="frame.src.framer.Framer.load_from_file" href="#frame.src.framer.Framer.load_from_file">load_from_file</a></code></li>
<li><code><a title="frame.src.framer.Framer.load_plugins" href="#frame.src.framer.Framer.load_plugins">load_plugins</a></code></li>
<li><code><a title="frame.src.framer.Framer.notify_observers" href="#frame.src.framer.Framer.notify_observers">notify_observers</a></code></li>
<li><code><a title="frame.src.framer.Framer.perceptions_queue" href="#frame.src.framer.Framer.perceptions_queue">perceptions_queue</a></code></li>
<li><code><a title="frame.src.framer.Framer.perform_task" href="#frame.src.framer.Framer.perform_task">perform_task</a></code></li>
<li><code><a title="frame.src.framer.Framer.process_queued_perceptions" href="#frame.src.framer.Framer.process_queued_perceptions">process_queued_perceptions</a></code></li>
<li><code><a title="frame.src.framer.Framer.prompt" href="#frame.src.framer.Framer.prompt">prompt</a></code></li>
<li><code><a title="frame.src.framer.Framer.remove_observer" href="#frame.src.framer.Framer.remove_observer">remove_observer</a></code></li>
<li><code><a title="frame.src.framer.Framer.sense" href="#frame.src.framer.Framer.sense">sense</a></code></li>
<li><code><a title="frame.src.framer.Framer.use_plugin_action" href="#frame.src.framer.Framer.use_plugin_action">use_plugin_action</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="frame.src.framer.FramerConfig" href="#frame.src.framer.FramerConfig">FramerConfig</a></code></h4>
<ul class="">
<li><code><a title="frame.src.framer.FramerConfig.default_model" href="#frame.src.framer.FramerConfig.default_model">default_model</a></code></li>
<li><code><a title="frame.src.framer.FramerConfig.description" href="#frame.src.framer.FramerConfig.description">description</a></code></li>
<li><code><a title="frame.src.framer.FramerConfig.gender" href="#frame.src.framer.FramerConfig.gender">gender</a></code></li>
<li><code><a title="frame.src.framer.FramerConfig.get" href="#frame.src.framer.FramerConfig.get">get</a></code></li>
<li><code><a title="frame.src.framer.FramerConfig.goals" href="#frame.src.framer.FramerConfig.goals">goals</a></code></li>
<li><code><a title="frame.src.framer.FramerConfig.is_multi_modal" href="#frame.src.framer.FramerConfig.is_multi_modal">is_multi_modal</a></code></li>
<li><code><a title="frame.src.framer.FramerConfig.llm_frequency_penalty" href="#frame.src.framer.FramerConfig.llm_frequency_penalty">llm_frequency_penalty</a></code></li>
<li><code><a title="frame.src.framer.FramerConfig.llm_max_tokens" href="#frame.src.framer.FramerConfig.llm_max_tokens">llm_max_tokens</a></code></li>
<li><code><a title="frame.src.framer.FramerConfig.llm_presence_penalty" href="#frame.src.framer.FramerConfig.llm_presence_penalty">llm_presence_penalty</a></code></li>
<li><code><a title="frame.src.framer.FramerConfig.llm_temperature" href="#frame.src.framer.FramerConfig.llm_temperature">llm_temperature</a></code></li>
<li><code><a title="frame.src.framer.FramerConfig.llm_top_p" href="#frame.src.framer.FramerConfig.llm_top_p">llm_top_p</a></code></li>
<li><code><a title="frame.src.framer.FramerConfig.mem0_api_key" href="#frame.src.framer.FramerConfig.mem0_api_key">mem0_api_key</a></code></li>
<li><code><a title="frame.src.framer.FramerConfig.model" href="#frame.src.framer.FramerConfig.model">model</a></code></li>
<li><code><a title="frame.src.framer.FramerConfig.model_computed_fields" href="#frame.src.framer.FramerConfig.model_computed_fields">model_computed_fields</a></code></li>
<li><code><a title="frame.src.framer.FramerConfig.model_config" href="#frame.src.framer.FramerConfig.model_config">model_config</a></code></li>
<li><code><a title="frame.src.framer.FramerConfig.model_fields" href="#frame.src.framer.FramerConfig.model_fields">model_fields</a></code></li>
<li><code><a title="frame.src.framer.FramerConfig.multi_modal_model" href="#frame.src.framer.FramerConfig.multi_modal_model">multi_modal_model</a></code></li>
<li><code><a title="frame.src.framer.FramerConfig.name" href="#frame.src.framer.FramerConfig.name">name</a></code></li>
<li><code><a title="frame.src.framer.FramerConfig.permissions" href="#frame.src.framer.FramerConfig.permissions">permissions</a></code></li>
<li><code><a title="frame.src.framer.FramerConfig.recent_memories_limit" href="#frame.src.framer.FramerConfig.recent_memories_limit">recent_memories_limit</a></code></li>
<li><code><a title="frame.src.framer.FramerConfig.roles" href="#frame.src.framer.FramerConfig.roles">roles</a></code></li>
<li><code><a title="frame.src.framer.FramerConfig.singleton" href="#frame.src.framer.FramerConfig.singleton">singleton</a></code></li>
<li><code><a title="frame.src.framer.FramerConfig.soul_seed" href="#frame.src.framer.FramerConfig.soul_seed">soul_seed</a></code></li>
<li><code><a title="frame.src.framer.FramerConfig.use_local_model" href="#frame.src.framer.FramerConfig.use_local_model">use_local_model</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="frame.src.framer.FramerFactory" href="#frame.src.framer.FramerFactory">FramerFactory</a></code></h4>
<ul class="">
<li><code><a title="frame.src.framer.FramerFactory.create_framer" href="#frame.src.framer.FramerFactory.create_framer">create_framer</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.1</a>.</p>
</footer>
</body>
</html>
