<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.1">
<title>frame.src.framer.framer API documentation</title>
<meta name="description" content="">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>frame.src.framer.framer</code></h1>
</header>
<section id="section-intro">
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="frame.src.framer.framer.Framer"><code class="flex name class">
<span>class <span class="ident">Framer</span></span>
<span>(</span><span>config: <a title="frame.src.framer.config.FramerConfig" href="config.html#frame.src.framer.config.FramerConfig">FramerConfig</a>, llm_service: <a title="frame.src.services.llm.main.LLMService" href="../services/llm/main.html#frame.src.services.llm.main.LLMService">LLMService</a>, agency: <a title="frame.src.framer.agency.agency.Agency" href="agency/agency.html#frame.src.framer.agency.agency.Agency">Agency</a>, brain: <a title="frame.src.framer.brain.brain.Brain" href="brain/brain.html#frame.src.framer.brain.brain.Brain">Brain</a>, soul: <a title="frame.src.framer.soul.soul.Soul" href="soul/soul.html#frame.src.framer.soul.soul.Soul">Soul</a>, workflow_manager: <a title="frame.src.framer.agency.tasks.workflow.workflow_manager.WorkflowManager" href="agency/tasks/workflow/workflow_manager.html#frame.src.framer.agency.tasks.workflow.workflow_manager.WorkflowManager">WorkflowManager</a>, memory_service: Optional[<a title="frame.src.services.memory.main.MemoryService" href="../services/memory/main.html#frame.src.services.memory.main.MemoryService">MemoryService</a>] = None, eq_service: Optional[<a title="frame.src.services.eq.main.EQService" href="../services/eq/main.html#frame.src.services.eq.main.EQService">EQService</a>] = None, roles: Optional[List[Dict[str, Any]]] = None, goals: Optional[List[Dict[str, Any]]] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>The Framer class represents an AI agent with cognitive capabilities. It integrates various components
such as agency, brain, soul, and workflow management to create a comprehensive AI entity capable of
processing perceptions, making decisions, and executing tasks.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>config</code></strong> :&ensp;<code>FramerConfig</code></dt>
<dd>Configuration settings for the Framer.</dd>
<dt><strong><code>llm_service</code></strong> :&ensp;<code>LLMService</code></dt>
<dd>The language model service to be used by the Framer.</dd>
<dt><strong><code>agency</code></strong> :&ensp;<code>Agency</code></dt>
<dd>Manages roles, goals, tasks, and workflows for the Framer.</dd>
<dt><strong><code>brain</code></strong> :&ensp;<code>Brain</code></dt>
<dd>Handles decision-making processes, integrating perceptions, memories, and thoughts.</dd>
<dt><strong><code>soul</code></strong> :&ensp;<code>Soul</code></dt>
<dd>Represents the core essence and personality of a Framer.</dd>
<dt><strong><code>workflow_manager</code></strong> :&ensp;<code>WorkflowManager</code></dt>
<dd>Manages workflows and tasks.</dd>
<dt><strong><code>memory_service</code></strong> :&ensp;<code>Optional[MemoryService]</code></dt>
<dd>Service for managing memory. Default is None.</dd>
<dt><strong><code>eq_service</code></strong> :&ensp;<code>Optional[EQService]</code></dt>
<dd>Service for managing emotional intelligence. Default is None.</dd>
<dt><strong><code>roles</code></strong> :&ensp;<code>Optional[List[Dict[str, Any]]]</code></dt>
<dd>List of roles for the Framer. Default is None.</dd>
<dt><strong><code>goals</code></strong> :&ensp;<code>Optional[List[Dict[str, Any]]]</code></dt>
<dd>List of goals for the Framer. Default is None.</dd>
<dt><strong><code>observers</code></strong> :&ensp;<code>List[Observer]</code></dt>
<dd>List of observer functions to notify on decisions.</dd>
<dt><strong><code>can_execute</code></strong> :&ensp;<code>bool</code></dt>
<dd>Determines if decisions are executed automatically. Default is True.</dd>
<dt><strong><code>acting</code></strong> :&ensp;<code>bool</code></dt>
<dd>Indicates if the Framer is actively processing perceptions. Default is False.</dd>
</dl>
<p>Initialize a Framer instance.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>config</code></strong> :&ensp;<code>FramerConfig</code></dt>
<dd>Configuration settings for the Framer.</dd>
<dt><strong><code>llm_service</code></strong> :&ensp;<code>LLMService</code></dt>
<dd>The language model service to be used by the Framer.</dd>
<dt><strong><code>agency</code></strong> :&ensp;<code>Agency</code></dt>
<dd>Manages roles, goals, tasks, and workflows for the Framer.</dd>
<dt><strong><code>brain</code></strong> :&ensp;<code>Brain</code></dt>
<dd>Handles decision-making processes, integrating perceptions, memories, and thoughts.</dd>
<dt><strong><code>soul</code></strong> :&ensp;<code>Soul</code></dt>
<dd>Represents the core essence and personality of a Framer.</dd>
<dt><strong><code>workflow_manager</code></strong> :&ensp;<code>WorkflowManager</code></dt>
<dd>Manages workflows and tasks.</dd>
<dt><strong><code>memory_service</code></strong> :&ensp;<code>Optional[MemoryService]</code></dt>
<dd>Service for managing memory. Default is None.</dd>
<dt><strong><code>eq_service</code></strong> :&ensp;<code>Optional[EQService]</code></dt>
<dd>Service for managing emotional intelligence. Default is None.</dd>
<dt><strong><code>roles</code></strong> :&ensp;<code>Optional[List[Dict[str, Any]]]</code></dt>
<dd>List of roles for the Framer. Default is None.</dd>
<dt><strong><code>goals</code></strong> :&ensp;<code>Optional[List[Dict[str, Any]]]</code></dt>
<dd>List of goals for the Framer. Default is None.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Framer:
    &#34;&#34;&#34;
    The Framer class represents an AI agent with cognitive capabilities. It integrates various components
    such as agency, brain, soul, and workflow management to create a comprehensive AI entity capable of
    processing perceptions, making decisions, and executing tasks.

    Attributes:
        config (FramerConfig): Configuration settings for the Framer.
        llm_service (LLMService): The language model service to be used by the Framer.
        agency (Agency): Manages roles, goals, tasks, and workflows for the Framer.
        brain (Brain): Handles decision-making processes, integrating perceptions, memories, and thoughts.
        soul (Soul): Represents the core essence and personality of a Framer.
        workflow_manager (WorkflowManager): Manages workflows and tasks.
        memory_service (Optional[MemoryService]): Service for managing memory. Default is None.
        eq_service (Optional[EQService]): Service for managing emotional intelligence. Default is None.
        roles (Optional[List[Dict[str, Any]]]): List of roles for the Framer. Default is None.
        goals (Optional[List[Dict[str, Any]]]): List of goals for the Framer. Default is None.
        observers (List[Observer]): List of observer functions to notify on decisions.
        can_execute (bool): Determines if decisions are executed automatically. Default is True.
        acting (bool): Indicates if the Framer is actively processing perceptions. Default is False.
    &#34;&#34;&#34;

    def __init__(
        self,
        config: FramerConfig,
        llm_service: LLMService,
        agency: Agency,
        brain: Brain,
        soul: Soul,
        workflow_manager: WorkflowManager,
        memory_service: Optional[MemoryService] = None,
        eq_service: Optional[EQService] = None,
        roles: Optional[List[Dict[str, Any]]] = None,
        goals: Optional[List[Dict[str, Any]]] = None,
    ):
        &#34;&#34;&#34;
        Initialize a Framer instance.

        Args:
            config (FramerConfig): Configuration settings for the Framer.
            llm_service (LLMService): The language model service to be used by the Framer.
            agency (Agency): Manages roles, goals, tasks, and workflows for the Framer.
            brain (Brain): Handles decision-making processes, integrating perceptions, memories, and thoughts.
            soul (Soul): Represents the core essence and personality of a Framer.
            workflow_manager (WorkflowManager): Manages workflows and tasks.
            memory_service (Optional[MemoryService]): Service for managing memory. Default is None.
            eq_service (Optional[EQService]): Service for managing emotional intelligence. Default is None.
            roles (Optional[List[Dict[str, Any]]]): List of roles for the Framer. Default is None.
            goals (Optional[List[Dict[str, Any]]]): List of goals for the Framer. Default is None.
        &#34;&#34;&#34;
        self._streamed_response = {&#34;status&#34;: &#34;pending&#34;, &#34;result&#34;: &#34;&#34;}
        self.config = config
        self.llm_service = llm_service
        self.agency = agency
        self.brain = brain
        self.soul = soul
        self.workflow_manager = workflow_manager
        self.memory_service = memory_service
        self.eq_service = eq_service
        self._dynamic_model_choice = False
        self.observers = []
        self.plugins = {}  # Initialize plugins attribute
        self.can_execute = True  # Add can_execute attribute
        self.acting = False

        # Initialize roles and goals
        self.roles = roles
        self.goals = goals

        # Start acting by default
        self.act()

    @classmethod
    async def create(
        cls,
        config: FramerConfig,
        llm_service: LLMService,
        soul_seed: Optional[Union[str, Dict[str, Any]]] = None,
        memory_service: Optional[MemoryService] = None,
        eq_service: Optional[EQService] = None,
    ) -&gt; &#34;Framer&#34;:
        agency = Agency(llm_service=llm_service, context={}, execution_context=None)

        # Generate roles and goals if they are None
        roles = config.roles
        goals = config.goals

        soul = Soul(seed=config.soul_seed)
        brain = Brain(
            llm_service=llm_service,
            default_model=config.default_model,
            roles=roles,
            goals=goals,
            soul=soul,
        )
        workflow_manager = WorkflowManager()

        framer = cls(
            config=config,
            llm_service=llm_service,
            agency=agency,
            brain=brain,
            soul=soul,
            workflow_manager=workflow_manager,
            memory_service=memory_service,
            eq_service=eq_service,
            roles=roles,
            goals=goals,
        )

        await framer.initialize()
        # Notify observers about the Framer being opened
        for observer in framer.observers:
            if hasattr(observer, &#34;on_framer_opened&#34;):
                observer.on_framer_opened(framer)

        return framer

    def act(self):
        &#34;&#34;&#34;
        Enable the Framer to process perceptions and make decisions.

        This method sets the Framer to an active state, allowing it to respond
        to perceptions and execute tasks. It is automatically called during
        initialization to ensure the Framer starts acting immediately.
        &#34;&#34;&#34;
        self.acting = True

    async def initialize(self):
        &#34;&#34;&#34;Initialize the Framer with roles and goals.&#34;&#34;&#34;
        self.act()  # Start acting after initialization

        if not self.roles:
            self.roles, _ = await self.agency.generate_roles_and_goals()
        if not self.goals:
            _, self.goals = await self.agency.generate_roles_and_goals()

        self.agency.set_roles(self.roles)
        self.agency.set_goals(self.goals)
        &#34;&#34;&#34;Disable the Framer from processing perceptions and making decisions.&#34;&#34;&#34;
        self.acting = False

    def export_to_markdown(self, file_path: str) -&gt; None:
        &#34;&#34;&#34;
        Export the Framer configuration to a Markdown file.

        This method allows the Framer agent to be fully exported into a Markdown format,
        making it portable and easy to use inside a prompt to any other LLM. This
        portability enables the Framer agents to be shared and consumed by other
        systems, facilitating interoperability and reuse.

        Args:
            file_path (str): The path to the file where the Markdown will be saved.
        &#34;&#34;&#34;
        from frame.src.utils.config_parser import export_config_to_markdown

        export_config_to_markdown(self.config, file_path)
        &#34;&#34;&#34;
        Export the Framer configuration to a JSON file.

        This method allows the Framer agent to be fully exported into a JSON format,
        making it portable and easy to use inside a prompt to any other LLM. This
        portability enables the Framer agents to be shared and consumed by other
        systems, facilitating interoperability and reuse.

        Args:
            file_path (str): The path to the file where the JSON will be saved.
        &#34;&#34;&#34;
        import json

        with open(file_path, &#34;w&#34;) as file:
            json.dump(
                {
                    &#34;config&#34;: self.config.to_dict() if hasattr(self.config, &#34;to_dict&#34;) else self.config,
                    &#34;roles&#34;: self.roles,
                    &#34;goals&#34;: self.goals,
                },
                file,
                indent=4,
                default=str  # Use default=str to handle non-serializable objects
            )

    @classmethod
    def load_from_file(
        cls,
        file_path: str,
        llm_service: LLMService,
        memory_service: Optional[MemoryService] = None,
        eq_service: Optional[EQService] = None,
    ) -&gt; &#34;Framer&#34;:
        &#34;&#34;&#34;
        Load a Framer configuration from a file.

        This method allows importing a Framer agent from a JSON or markdown file,
        enabling the reconstruction of the agent&#39;s state and configuration. This
        functionality is crucial for restoring Framer agents from saved states,
        ensuring continuity and consistency across different sessions or environments.

        Args:
            file_path (str): The path to the configuration file.
            llm_service (LLMService): Language model service.
            memory_service (Optional[MemoryService]): Memory service for the Framer.
            eq_service (Optional[EQService]): Emotional intelligence service for the Framer.

        Returns:
            Framer: A new Framer instance configured from the file.
        &#34;&#34;&#34;
        config = parse_json_config(file_path)
        return cls(
            config=config,
            llm_service=llm_service,
            agency=Agency(llm_service=llm_service, context=None),
            brain=Brain(
                llm_service=llm_service,
                default_model=config.default_model,
                roles=config.roles,
                goals=config.goals,
                soul=Soul(seed=config.soul_seed),
            ),
            soul=Soul(seed=config.soul_seed),
            workflow_manager=WorkflowManager(),
            memory_service=memory_service,
            eq_service=eq_service,
            roles=config.roles,
            goals=config.goals,
        )

    @classmethod
    def load_from_file(
        cls,
        file_path: str,
        llm_service: LLMService,
        memory_service: Optional[MemoryService] = None,
        eq_service: Optional[EQService] = None,
    ) -&gt; &#34;Framer&#34;:
        &#34;&#34;&#34;
        Load a Framer configuration from a file.

        This method allows importing a Framer agent from a JSON or markdown file,
        enabling the reconstruction of the agent&#39;s state and configuration. This
        functionality is crucial for restoring Framer agents from saved states,
        ensuring continuity and consistency across different sessions or environments.

        Args:
            file_path (str): The path to the configuration file.
            llm_service (LLMService): Language model service.
            memory_service (Optional[MemoryService]): Memory service for the Framer.
            eq_service (Optional[EQService]): Emotional intelligence service for the Framer.

        Returns:
            Framer: A new Framer instance configured from the file.
        &#34;&#34;&#34;
        config = parse_json_config(file_path)
        return cls(
            config=config,
            llm_service=llm_service,
            agency=Agency(llm_service=llm_service, context=None),
            brain=Brain(
                llm_service=llm_service,
                default_model=config.default_model,
                roles=config.roles,
                goals=config.goals,
                soul=Soul(seed=config.soul_seed),
            ),
            soul=Soul(seed=config.soul_seed),
            workflow_manager=WorkflowManager(),
            memory_service=memory_service,
            eq_service=eq_service,
            roles=config.roles,
            goals=config.goals,
        )
        &#34;&#34;&#34;
        Export the Framer configuration to a JSON file.

        This method allows the Framer agent to be fully exported into a JSON format,
        making it portable and easy to use inside a prompt to any other LLM. This
        portability enables the Framer agents to be shared and consumed by other
        systems, facilitating interoperability and reuse.

        Args:
            file_path (str): The path to the file where the JSON will be saved.
        &#34;&#34;&#34;
        import json

        with open(file_path, &#34;w&#34;) as file:
            json.dump(
                {
                    &#34;config&#34;: self.config.to_dict(),
                    &#34;roles&#34;: self.roles,
                    &#34;goals&#34;: self.goals,
                },
                file,
                indent=4,
            )

    @classmethod
    def load_from_file(
        cls,
        file_path: str,
        llm_service: LLMService,
        memory_service: Optional[MemoryService] = None,
        eq_service: Optional[EQService] = None,
    ) -&gt; &#34;Framer&#34;:
        &#34;&#34;&#34;
        Load a Framer configuration from a file.

        This method allows importing a Framer agent from a JSON or markdown file,
        enabling the reconstruction of the agent&#39;s state and configuration. This
        functionality is crucial for restoring Framer agents from saved states,
        ensuring continuity and consistency across different sessions or environments.

        Args:
            file_path (str): The path to the configuration file.
            llm_service (LLMService): Language model service.
            memory_service (Optional[MemoryService]): Memory service for the Framer.
            eq_service (Optional[EQService]): Emotional intelligence service for the Framer.

        Returns:
            Framer: A new Framer instance configured from the file.
        &#34;&#34;&#34;
        config = parse_json_config(file_path)
        return cls(
            config=config,
            llm_service=llm_service,
            agency=Agency(llm_service=llm_service, context=None),
            brain=Brain(
                llm_service=llm_service,
                default_model=config.default_model,
                roles=config.roles,
                goals=config.goals,
                soul=Soul(seed=config.soul_seed),
            ),
            soul=Soul(seed=config.soul_seed),
            workflow_manager=WorkflowManager(),
            memory_service=memory_service,
            eq_service=eq_service,
            roles=config.roles,
            goals=config.goals,
        )

    async def perform_task(self, task: Dict[str, Any]) -&gt; Dict[str, Any]:
        &#34;&#34;&#34;
        Perform a task asynchronously.

        Args:
            task (Dict[str, Any]): Dictionary containing task details.

        Returns:
            Dict[str, Any]: Result of the task execution.
        &#34;&#34;&#34;
        logger.debug(f&#34;perform_task called with task: {task}&#34;)
        valid_task_keys = Task.__annotations__.keys()
        task_filtered = {k: v for k, v in task.items() if k in valid_task_keys}
        # Ensure required fields are present
        if &#34;description&#34; not in task_filtered:
            task_filtered[&#34;description&#34;] = &#34;Default Task Description&#34;
        if &#34;workflow_id&#34; not in task_filtered:
            task_filtered[&#34;workflow_id&#34;] = &#34;default&#34;

        task_obj = Task(**task_filtered)
        result = await self.agency.perform_task(task_obj)
        return result if result is not None else {&#34;output&#34;: &#34;No result returned&#34;}

    async def sense(self, perception: Any) -&gt; Decision:
        &#34;&#34;&#34;
        Process a perception and make a decision.

        Args:
            perception (Any): The perception to process, can be a Perception object or a dictionary.

        Returns:
            Decision: The decision made based on the perception.
        &#34;&#34;&#34;
        if not self.acting:
            logger.warning(&#34;Framer is not acting. Cannot process perceptions.&#34;)
            return Decision(
                action=&#34;error&#34;, parameters={}, reasoning=&#34;Framer is halted.&#34;
            )
            perception = Perception.from_dict(perception)
        decision = await self.brain.process_perception(
            perception, self.agency.get_goals()
        )
        if hasattr(self, &#34;can_execute&#34;) and self.can_execute:
            await self.brain.execute_decision(decision)
        logger.debug(f&#34;Processed perception: {perception}, Decision: {decision}&#34;)
        self.notify_observers(decision)
        return decision

    def add_observer(self, observer: Observer) -&gt; None:
        &#34;&#34;&#34;
        Add an observer to be notified when a decision is made.

        Args:
            observer (Observer): The observer function to add.
        &#34;&#34;&#34;
        self.observers.append(observer)

    def remove_observer(self, observer: Observer) -&gt; None:
        &#34;&#34;&#34;
        Remove an observer.

        Args:
            observer (Observer): The observer function to remove.
        &#34;&#34;&#34;
        self.observers.remove(observer)

    def notify_observers(self, decision: Decision) -&gt; None:
        &#34;&#34;&#34;
        Notify all observers about a decision.

        Args:
            decision (Decision): The decision to notify observers about.
        &#34;&#34;&#34;
        for observer in self.observers:
            observer(decision)

        # Notify plugins about the decision
        for plugin in self.plugins.values():
            if hasattr(plugin, &#34;on_decision_made&#34;):
                plugin.on_decision_made(decision)

    async def close(self) -&gt; None:
        &#34;&#34;&#34;
        Optimize and clear all memory for the Framer.

        This method ensures that all tasks and workflows are closed properly,
        and any resources or memory used by the Framer are released. It is
        important to call this method when the Framer is no longer needed to
        prevent memory leaks and ensure optimal performance. This method
        should be called to gracefully shut down the Framer.
        &#34;&#34;&#34;
        # Close all workflows
        for workflow in self.workflow_manager.workflows.values():
            workflow.set_final_task(None)  # Clear final tasks
            for task in workflow.tasks:
                task.update_status(TaskStatus.COMPLETED)  # Mark tasks as completed

        # Clear memory
        if self.memory_service:
            self.memory_service.clear()

        # Notify observers and plugins about closure and opening
        for observer in self.observers:
            if hasattr(observer, &#34;on_framer_closed&#34;):
                observer.on_framer_closed(self)

        if hasattr(self, &#34;plugins&#34;):
            for plugin in self.plugins.values():
                if hasattr(plugin, &#34;on_framer_closed&#34;):
                    plugin.on_framer_closed(self)</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="frame.src.framer.framer.Framer.create"><code class="name flex">
<span>async def <span class="ident">create</span></span>(<span>config: <a title="frame.src.framer.config.FramerConfig" href="config.html#frame.src.framer.config.FramerConfig">FramerConfig</a>, llm_service: <a title="frame.src.services.llm.main.LLMService" href="../services/llm/main.html#frame.src.services.llm.main.LLMService">LLMService</a>, soul_seed: Union[str, Dict[str, Any], ForwardRef(None)] = None, memory_service: Optional[<a title="frame.src.services.memory.main.MemoryService" href="../services/memory/main.html#frame.src.services.memory.main.MemoryService">MemoryService</a>] = None, eq_service: Optional[<a title="frame.src.services.eq.main.EQService" href="../services/eq/main.html#frame.src.services.eq.main.EQService">EQService</a>] = None) ‑> <a title="frame.src.framer.framer.Framer" href="#frame.src.framer.framer.Framer">Framer</a></span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="frame.src.framer.framer.Framer.load_from_file"><code class="name flex">
<span>def <span class="ident">load_from_file</span></span>(<span>file_path: str, llm_service: <a title="frame.src.services.llm.main.LLMService" href="../services/llm/main.html#frame.src.services.llm.main.LLMService">LLMService</a>, memory_service: Optional[<a title="frame.src.services.memory.main.MemoryService" href="../services/memory/main.html#frame.src.services.memory.main.MemoryService">MemoryService</a>] = None, eq_service: Optional[<a title="frame.src.services.eq.main.EQService" href="../services/eq/main.html#frame.src.services.eq.main.EQService">EQService</a>] = None) ‑> <a title="frame.src.framer.framer.Framer" href="#frame.src.framer.framer.Framer">Framer</a></span>
</code></dt>
<dd>
<div class="desc"><p>Load a Framer configuration from a file.</p>
<p>This method allows importing a Framer agent from a JSON or markdown file,
enabling the reconstruction of the agent's state and configuration. This
functionality is crucial for restoring Framer agents from saved states,
ensuring continuity and consistency across different sessions or environments.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>file_path</code></strong> :&ensp;<code>str</code></dt>
<dd>The path to the configuration file.</dd>
<dt><strong><code>llm_service</code></strong> :&ensp;<code>LLMService</code></dt>
<dd>Language model service.</dd>
<dt><strong><code>memory_service</code></strong> :&ensp;<code>Optional[MemoryService]</code></dt>
<dd>Memory service for the Framer.</dd>
<dt><strong><code>eq_service</code></strong> :&ensp;<code>Optional[EQService]</code></dt>
<dd>Emotional intelligence service for the Framer.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="frame.src.framer.framer.Framer" href="#frame.src.framer.framer.Framer">Framer</a></code></dt>
<dd>A new Framer instance configured from the file.</dd>
</dl></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="frame.src.framer.framer.Framer.act"><code class="name flex">
<span>def <span class="ident">act</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Enable the Framer to process perceptions and make decisions.</p>
<p>This method sets the Framer to an active state, allowing it to respond
to perceptions and execute tasks. It is automatically called during
initialization to ensure the Framer starts acting immediately.</p></div>
</dd>
<dt id="frame.src.framer.framer.Framer.add_observer"><code class="name flex">
<span>def <span class="ident">add_observer</span></span>(<span>self, observer: Callable[[<a title="frame.src.framer.brain.decision.decision.Decision" href="brain/decision/decision.html#frame.src.framer.brain.decision.decision.Decision">Decision</a>], None]) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Add an observer to be notified when a decision is made.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>observer</code></strong> :&ensp;<code>Observer</code></dt>
<dd>The observer function to add.</dd>
</dl></div>
</dd>
<dt id="frame.src.framer.framer.Framer.close"><code class="name flex">
<span>async def <span class="ident">close</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Optimize and clear all memory for the Framer.</p>
<p>This method ensures that all tasks and workflows are closed properly,
and any resources or memory used by the Framer are released. It is
important to call this method when the Framer is no longer needed to
prevent memory leaks and ensure optimal performance. This method
should be called to gracefully shut down the Framer.</p></div>
</dd>
<dt id="frame.src.framer.framer.Framer.export_to_markdown"><code class="name flex">
<span>def <span class="ident">export_to_markdown</span></span>(<span>self, file_path: str) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Export the Framer configuration to a Markdown file.</p>
<p>This method allows the Framer agent to be fully exported into a Markdown format,
making it portable and easy to use inside a prompt to any other LLM. This
portability enables the Framer agents to be shared and consumed by other
systems, facilitating interoperability and reuse.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>file_path</code></strong> :&ensp;<code>str</code></dt>
<dd>The path to the file where the Markdown will be saved.</dd>
</dl></div>
</dd>
<dt id="frame.src.framer.framer.Framer.initialize"><code class="name flex">
<span>async def <span class="ident">initialize</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Initialize the Framer with roles and goals.</p></div>
</dd>
<dt id="frame.src.framer.framer.Framer.notify_observers"><code class="name flex">
<span>def <span class="ident">notify_observers</span></span>(<span>self, decision: <a title="frame.src.framer.brain.decision.decision.Decision" href="brain/decision/decision.html#frame.src.framer.brain.decision.decision.Decision">Decision</a>) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Notify all observers about a decision.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>decision</code></strong> :&ensp;<code>Decision</code></dt>
<dd>The decision to notify observers about.</dd>
</dl></div>
</dd>
<dt id="frame.src.framer.framer.Framer.perform_task"><code class="name flex">
<span>async def <span class="ident">perform_task</span></span>(<span>self, task: Dict[str, Any]) ‑> Dict[str, Any]</span>
</code></dt>
<dd>
<div class="desc"><p>Perform a task asynchronously.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>task</code></strong> :&ensp;<code>Dict[str, Any]</code></dt>
<dd>Dictionary containing task details.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Dict[str, Any]</code></dt>
<dd>Result of the task execution.</dd>
</dl></div>
</dd>
<dt id="frame.src.framer.framer.Framer.remove_observer"><code class="name flex">
<span>def <span class="ident">remove_observer</span></span>(<span>self, observer: Callable[[<a title="frame.src.framer.brain.decision.decision.Decision" href="brain/decision/decision.html#frame.src.framer.brain.decision.decision.Decision">Decision</a>], None]) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Remove an observer.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>observer</code></strong> :&ensp;<code>Observer</code></dt>
<dd>The observer function to remove.</dd>
</dl></div>
</dd>
<dt id="frame.src.framer.framer.Framer.sense"><code class="name flex">
<span>async def <span class="ident">sense</span></span>(<span>self, perception: Any) ‑> <a title="frame.src.framer.brain.decision.decision.Decision" href="brain/decision/decision.html#frame.src.framer.brain.decision.decision.Decision">Decision</a></span>
</code></dt>
<dd>
<div class="desc"><p>Process a perception and make a decision.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>perception</code></strong> :&ensp;<code>Any</code></dt>
<dd>The perception to process, can be a Perception object or a dictionary.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Decision</code></dt>
<dd>The decision made based on the perception.</dd>
</dl></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="frame.src.framer" href="index.html">frame.src.framer</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="frame.src.framer.framer.Framer" href="#frame.src.framer.framer.Framer">Framer</a></code></h4>
<ul class="two-column">
<li><code><a title="frame.src.framer.framer.Framer.act" href="#frame.src.framer.framer.Framer.act">act</a></code></li>
<li><code><a title="frame.src.framer.framer.Framer.add_observer" href="#frame.src.framer.framer.Framer.add_observer">add_observer</a></code></li>
<li><code><a title="frame.src.framer.framer.Framer.close" href="#frame.src.framer.framer.Framer.close">close</a></code></li>
<li><code><a title="frame.src.framer.framer.Framer.create" href="#frame.src.framer.framer.Framer.create">create</a></code></li>
<li><code><a title="frame.src.framer.framer.Framer.export_to_markdown" href="#frame.src.framer.framer.Framer.export_to_markdown">export_to_markdown</a></code></li>
<li><code><a title="frame.src.framer.framer.Framer.initialize" href="#frame.src.framer.framer.Framer.initialize">initialize</a></code></li>
<li><code><a title="frame.src.framer.framer.Framer.load_from_file" href="#frame.src.framer.framer.Framer.load_from_file">load_from_file</a></code></li>
<li><code><a title="frame.src.framer.framer.Framer.notify_observers" href="#frame.src.framer.framer.Framer.notify_observers">notify_observers</a></code></li>
<li><code><a title="frame.src.framer.framer.Framer.perform_task" href="#frame.src.framer.framer.Framer.perform_task">perform_task</a></code></li>
<li><code><a title="frame.src.framer.framer.Framer.remove_observer" href="#frame.src.framer.framer.Framer.remove_observer">remove_observer</a></code></li>
<li><code><a title="frame.src.framer.framer.Framer.sense" href="#frame.src.framer.framer.Framer.sense">sense</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.1</a>.</p>
</footer>
</body>
</html>
